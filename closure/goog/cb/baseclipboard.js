goog.provide('office.clipboard.BaseClipboard');

goog.require('office.clipboard.ClipboardError');
goog.require('office.clipboard.Digest');
goog.require('office.clipboard.MimeClipboard');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.async.Deferred');
goog.require('goog.async.DeferredList');
goog.require('goog.debug.Error');
goog.require('goog.string');



/**
 * Base class for clipboards. This base class provides default implementations
 * for basic clipboard functionality. In particular, it provides a default
 * implementation for a good deal of asynchronous processing that would
 * otherwise have to be written from scratch. Subclasses need to
 * implement the XXXInternal methods, like getClipInternal etc.
 *
 * Handle management: every clip gets a non-null handle which makes handle
 *    management in subclasses straightforward. Also, handles are checked
 *    for correct scope when used (originate in same clipboard, is active).
 *    As the default handle is aliased to a non-null handle, there is a
 *    isDefaultHandle() utility method or cases where the default handle
 *    requires different processing than other handles.
 *
 *  Reduce burden of asynchronous implementations: In case one or more digests
 *    passed to getClipHandle() are deferred, the class will buffer all
 *    subsequent operations on the returned handle until immediate values are
 *    available for getClipHandleInternal to compute the matching handle.
 *
 * Clip GUID management: guid-handle associations are maintained, and each
 *    handle will always have an associated non-null guid (internally allocated
 *    if not provided by the caller). Because of this, guids are well suited to
 *    be used as keys for the actual clips maintained by the subclass.
 *
 *    The default getDigestsInternal() will return a guid digest based on the
 *    guid associated with the handle.
 *
 * @param {!Array.<string>} mimeTypes The MIME types.
 * @param {string=} opt_prefix Non-empty prefix string for clip handles.
 * @implements {office.clipboard.MimeClipboard}
 * @constructor
 * @struct
 */
office.clipboard.BaseClipboard = function(mimeTypes, opt_prefix) {

  /**
   * Map of active handles to associated guids.
   * @type {!Object.<string>}
   * @private
   */
  this.handles_ = {};

  /**
   * Map of deferred handles to associated contexts.
   * @typeÂ  {!Object.<!office.clipboard.BaseClipboardDeferredContext_>}
   * @private
   */
  this.deferredHandles_ = {};

  /**
   * The prefix for all handles generated by this clipboard. Having a common
   * prefix is useful for debugging.
   * @type {string}
   * @private
   */
  this.handlePrefix_ = opt_prefix || 'ch-';

  /**
   * The serial number of the next handle.
   * @type {number}
   * @private
   */
  this.nextHandle_ = 0;

  /**
   * The default handle. Always points to the most recently written clip.
   * @type {string}
   * @const
   * @private
   */
  this.defaultHandle_ = this.allocateContext_('');

  /**
   * The mime types.
   * @type {!Array.<string>}
   * @private
   */
  this.mimeTypes_ = mimeTypes;
  goog.array.sort(this.mimeTypes_);
};


/**
 * A guid representing an empty clip. Use this guid for digests when the current
 * clip cannot match any other clip.
 * @type {string}
 * @const
 * @protected
 */
office.clipboard.BaseClipboard.NULL_GUID = goog.events.getUniqueId('unique:not-clipboard');


/**
 * Sets clipboard clip, internal version. The internal version is
 * always called with a clip having an explicit, active (not finished) handle.
 * Note that for clipboards that may change state through other means than
 * setClip, an empty guid should typically be used with the default handle, as
 * the current guid may no longer match the most recent clip the next time the
 * default handle is used (because of external events changing the clip).
 *
 * @param {!office.clipboard.Clip} clip The clip to store.
 * @param {string} Guid that caller requests to have associated with this clip,
 *     or the empty string if none.
 * @param {string} handle The handle associated with the clip.
 * @throws {office.clipboard.ClipboardError} If an error occurs.
 * @protected
 */
office.clipboard.BaseClipboard.prototype.setClipInternal = goog.abstractMethod;


/**
 * Retrieves clip by given MIME type, internal version. The internal version is
 * always called with an explicit, active (not finished) handle, and an
 * explicit guid associated with the handle.
 *
 * @param {string} mimeType MIME type of the clip to retrieve.
 * @param {string} handle The clip handle.
 * @param {number|undefined} timeout Optional timeout in milliseconds. If
 *     unspecified or 0, no timeout is in effect.
 * @param {string} guid The clip guid associated with the handle, the empty
 *     string if none.
 * @return {!goog.async.Deferred} The retrieved clip. The clip MIME type and
 *     handle will be set to the mimeType and opt_handle parameters
 *     respectively.
 * @throws {office.clipboard.ClipboardError} If an error occurs.
 * @protected
 */
office.clipboard.BaseClipboard.prototype.getClipInternal = goog.abstractMethod;


/**
 * Frees any temporary resources associated with handle. Internal version.
 * By default does nothing.
 *
 * @param {string} handle Handle to finish.
 * @param {string} guid The clip guid associated with the handle.
 * @throws {office.clipboard.ClipboardError} If an error occurs.
 * @protected
 */
office.clipboard.BaseClipboard.prototype.finishInternal = function(handle, guid) {
};


/**
 * Retrieves digests for the clip, internal version. The default implementation
 * returns a GUID digest based on the guid associated with the handle.
 *
 * @param {string} handle Handle to the source clip.
 * @param {string} guid The clip guid associated with the handle.
 * @return {!Array.<!office.clipboard.Digest>} The clip digests.
 * @throws {office.clipboard.ClipboardError} If an error occurs.
 * @protected
 */
office.clipboard.BaseClipboard.prototype.getDigestsInternal =
    function(handle, guid) {
  this.checkHandle_(handle);
  return [new office.clipboard.Digest(office.clipboard.Digest.Type.GUID, guid)];
};


/**
 * Retrieves clip handle matching one or more digests, internal version. Works
 * as getClipHandle(), but is guaranteed to be called only with a list of
 * digests, where no digest value is deferred. The default implementation
 * matches by guid only.
 *
 * @param {!Array.<!office.clipboard.Digest>} digests The digests.
 * @return {string} Handle to a clip matching at least one digest.
 * @protected
 */
office.clipboard.BaseClipboard.prototype.getClipHandleInternal =
    function(digests) {
  var matchedHandle = office.clipboard.Digest.matchDigests(digests,
      office.clipboard.Digest.Type.GUID, goog.bind(this.allocateContext_, this));
  if (goog.isDefAndNotNull(matchedHandle)) {
    return matchedHandle;
  } else {
    return this.allocateContext_(office.clipboard.BaseClipboard.NULL_GUID);
  }
};


/**
 * @param {string} handle The handle to test.
 * @return {boolean} Whether the handle is the default handle.
 * @protected
 */
office.clipboard.BaseClipboard.prototype.isDefaultHandle = function(handle) {
  return handle == this.defaultHandle_;
};


/** @override */
office.clipboard.BaseClipboard.prototype.setClip = function(clip, opt_handle) {
  this.checkMime_(clip.getMimeType());
  var writeHandle = opt_handle || this.defaultHandle_;
  this.enqueue_(writeHandle, goog.bind(function(handle) {
    if (this.handles_[handle] == office.clipboard.BaseClipboard.NULL_GUID) {
      throw Error('Attempted to set clip with the NULL clip guid.');
    }

    this.setClipInternal(clip, this.handles_[handle], handle);
  }, this));
};


/** @override */
office.clipboard.BaseClipboard.prototype.getClip =
    function(mimeType, opt_handle, opt_timeout) {
  this.checkMime_(mimeType);
  var handle = opt_handle || this.defaultHandle_;
  return /** @type {!goog.async.Deferred} */ (this.enqueue_(handle, goog.bind(
      function(handle) {
        return this.getClipInternal(mimeType, handle, opt_timeout,
            this.handles_[handle]);
      }, this)));
};


/** @override */
office.clipboard.BaseClipboard.prototype.getClipHandle = function(opt_digests) {
  if (!opt_digests) {
    // Note: we don't hand out defaultHandle directly here so that it can't be
    // accidentally finished.
    return this.allocateContext_(this.handles_[this.defaultHandle_]);
  }
  var bucketedDigests =
      goog.array.bucket(opt_digests, function(digest) {
    return digest.getValue() instanceof goog.async.Deferred ? 1 : 0;
  });
  var immediateDigests = bucketedDigests[0] || [];
  var deferredDigests = bucketedDigests[1] || [];
  if (deferredDigests.length == 0) {
    // Only immediate digests.
    return this.getClipHandleInternal(immediateDigests);
  }

  // Set up digests callbacks.
  var deferredMatches = new goog.async.Deferred();
  var deferredValues = new goog.async.DeferredList(goog.array.map(
      deferredDigests, function(digest) {return digest.getValue()}));
  deferredValues.addCallback(function(digestValuesResult) {
    var allDigests = goog.array.reduce(digestValuesResult,
        function(values, result, ix) {
          if (result[0] && goog.isDefAndNotNull(result[1])) {
            values.push(new office.clipboard.Digest(deferredDigests[ix].getType(),
                result[1]));
          }
          return values;
        }, immediateDigests);
    deferredMatches.callback(this.getClipHandleInternal(allDigests));
  }, this);

  var handle = this.allocateDeferredContext_(deferredMatches, opt_digests);
  deferredMatches.addCallback(goog.bind(function(originalHandle, handle) {
    return (this.deferredHandles_[originalHandle].handle = handle);
  }, this, handle));
  return handle;
};


/** @override */
office.clipboard.BaseClipboard.prototype.getDigests = function(opt_handle) {
  this.checkHandle_(opt_handle);
  var handle = opt_handle || this.defaultHandle_;
  if (this.deferredHandles_[handle] && !this.deferredHandles_[handle].handle) {
    // This handle is still deferred; return the same digest that was used to
    // obtain the deferred handle (as by definition those match the deferred
    // handle).
    return this.deferredHandles_[handle].digests;
  }
  var result = null;
  var wrappedDigests = (this.enqueue_(handle, goog.bind(function(handle) {
    return goog.async.Deferred.succeed(
        this.getDigestsInternal(handle, this.handles_[handle]));
  }, this))).addBoth(function(res) {result = res});
  if (!wrappedDigests.hasFired()) {
    // This either happens because there was an exception (in result), or
    // the callback did not yet fire, which should not happen since the deferred
    // handle case was already eliminated above.
    throw result || new goog.debug.Error('Unexpected missing callback.');
  } else {
    return /** @type {!Array.<!office.clipboard.Digest>} */ (result);
  }
};


/** @override */
office.clipboard.BaseClipboard.prototype.finish = function(handle) {
  this.checkHandle_(handle);
  this.enqueue_(handle, goog.bind(function(originalHandle, handle) {
    if (this.deferredHandles_[originalHandle]) {
      delete this.deferredHandles_[originalHandle];
    }
    this.finishInternal(handle, this.handles_[handle]);
    delete this.handles_[handle];
  }, this, handle));
};


/** @override */
office.clipboard.BaseClipboard.prototype.getMimeTypes = function() {
  return this.mimeTypes_;
};


/**
 * Executes operation immediately or enqueues it, depending on the state of the
 * handle. Enqueued operations are added to the callback chain of the deferred
 * handle.
 *
 * @param {string} handle The operation handle.
 * @param {function(string):!goog.async.Deferred|undefined} clipOp The operation
 *     to enqueue. Called with a (non-deferred) handle corresponding to the
 *     original handle.
 * @return {!goog.async.Deferred|undefined} The immediate result of clipOp, or a
 *     deferred result if clipOp was enqueued.
 * @private
 */
office.clipboard.BaseClipboard.prototype.enqueue_ = function(handle, clipOp) {
  var isDeferredHandle = !!this.deferredHandles_[handle];
  var aliasedHandle =
      isDeferredHandle ? this.deferredHandles_[handle].handle : null;
  if (isDeferredHandle && !aliasedHandle) {
    var deferredResult = new goog.async.Deferred();
    this.deferredHandles_[handle].deferred.addCallback(
        function(handle) {
          try {
            var result = clipOp(handle);
            if (result instanceof goog.async.Deferred) {
              result.chainDeferred(deferredResult);
            } else {
              deferredResult.callback(result);
            }
          } catch (e) {
            deferredResult.errback(e);
          }
          return handle;
        }, this);
    return deferredResult;
  } else {
    return clipOp(aliasedHandle || handle);
  }
};


/**
 * Allocates a new context.
 * @param {?string=} opt_guid The guid. If unspecified, a random guid will be
 *    used.
 * @return {string} The handle for the allocated context.
 * @private
 */
office.clipboard.BaseClipboard.prototype.allocateContext_ = function(opt_guid) {
  var newHandle = this.handlePrefix_ + (this.nextHandle_++);
  this.handles_[newHandle] = this.emptyGuidToNew_(opt_guid);
  return newHandle;
};


/**
 * Allocates a new deferred context.
 * @param {!goog.async.Deferred} deferred The deferred.
 * @param {!Array} digests The digests associated with the context.
 * @return {string} Handle for the context.
 * @private
 */
office.clipboard.BaseClipboard.prototype.allocateDeferredContext_ =
    function(deferred, digests) {
  var newHandle = this.handlePrefix_ + (this.nextHandle_++);
  this.deferredHandles_[newHandle] =
      new office.clipboard.BaseClipboardDeferredContext_(deferred, digests);
  return newHandle;
};


/** @override */
office.clipboard.BaseClipboard.prototype.newClipHandle = function(opt_guid) {
  // While in general we can't guarantee the caller will pass unique guids, we
  // can at least check for the empty guid case (which would match the current
  // state).
  goog.asserts.assert(opt_guid != '',
      'Attempt to create new handle matching existing clip.');
  return this.allocateContext_(goog.isDefAndNotNull(opt_guid) ? opt_guid :
      this.newGuid());
};


/**
 * Makes sure handle is valid.
 * @param {?string=} opt_handle The handle to check.
 * @return {string|null|undefined} The handle (for chaining).
 * @private
 */
office.clipboard.BaseClipboard.prototype.checkHandle_ = function(opt_handle) {
  if (opt_handle) {
    if (!goog.string.startsWith(opt_handle, this.handlePrefix_)) {
      throw new office.clipboard.ClipboardError(
          office.clipboard.ClipboardError.Code.HANDLE_UNKNOWN, 'Foreign handle.');
    } else if (!goog.isDefAndNotNull(this.handles_[opt_handle]) &&
        !this.deferredHandles_[opt_handle]) {
      throw new office.clipboard.ClipboardError(
          office.clipboard.ClipboardError.Code.HANDLE_UNKNOWN,
          'Handle not active.');
    }
  }
  return opt_handle;
};


/**
 * Validates the MIME type.
 * @param {string} mimeType The MIME types.
 * @private
 */
office.clipboard.BaseClipboard.prototype.checkMime_ = function(mimeType) {
  if (goog.array.binarySearch(this.mimeTypes_, mimeType) < 0) {
    throw new office.clipboard.ClipboardError(
        office.clipboard.ClipboardError.Code.MIMETYPE_UNKNOWN);
  }
};


/**
 * Returns given guid or a new guid if the one given is empty (null or undef).
 * @param {undefined|null|string} guid The guid.
 * @return {string} The original guid or a new guid.
 * @private
 */
office.clipboard.BaseClipboard.prototype.emptyGuidToNew_ = function(guid) {
  if (goog.isDefAndNotNull(guid)) {
    return guid;
  } else {
    return this.newGuid();
  }
};


/**
 * Generates a new guid.
 * @return {string} A unique identifier.
 * @protected
 */
office.clipboard.BaseClipboard.prototype.newGuid = function() {
  return office.clipboard.MimeClipboard.newGuid();
};



/**
 * Context for deferred handles.
 * @param {!goog.async.Deferred} deferred The deferred associated with this
 *     handle.
 * @param {!Array.<!office.clipboard.Digest>} digests The digests for this handle.
 * @constructor
 * @struct
 * @private
 */
office.clipboard.BaseClipboardDeferredContext_ = function(deferred, digests) {

  /**
   * The handle.
   * @type {?string}
   */
  this.handle = null;

  /**
   * The deferred.
   * @type {!goog.async.Deferred}
   */
  this.deferred = deferred;

  /**
   * The digests.
   * @type {!Array.<!office.clipboard.Digest>}
   */
  this.digests = digests;
};

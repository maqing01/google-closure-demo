

/**
 * @fileoverview Helper methods for extracting and replacing header information
 * out of an image.  When a JPEG image is generated for client-side downsizing,
 * the entirety of the APP1 is extracted, a few fields updated, and finally
 * spliced into the new image.  Additionally, other segments of interest are
 * copied wholesale.
 *
 * @author thrasher@google.com (Chris Thrasher)
 */

goog.provide('apps.uploader.ExifHelper');

goog.require('goog.array');
goog.require('goog.fs');
goog.require('goog.math');


/**
 * Creates a new JPEG header out of an existing data stream.
 * @param {!ArrayBuffer} data The raw bytes out of the file.
 * @param {number} oldWidth Old width of the image, in pixels.
 * @param {number} oldHeight Old Height of the image, in pixels.
 * @param {number} newWidth New width of the image, in pixels.
 * @param {number} newHeight New height of the image, in pixels.
 * @return {?Object} A series of catenated header segments, if can be created.
 *     Null if it cannot.
 */
apps.uploader.ExifHelper.createHeader = function(data, oldWidth,
    oldHeight, newWidth, newHeight) {
  var oldBuffer = new Uint8Array(data);
  var appSegments = apps.uploader.ExifHelper.findSegmentsOfInterest_(oldBuffer);

  if (appSegments.length == 0) {
    return null;
  }

  // Find the total length of the new buffer.
  var totalBytes = 0;
  goog.array.forEach(appSegments, function(x) { totalBytes += x.length; });

  // Copy.
  var offset = 0;
  var newBuffer = new Uint8Array(totalBytes);
  goog.array.forEach(appSegments, function(segment) {
    newBuffer.set(oldBuffer.subarray(segment.offset,
        segment.offset + segment.length),
        offset);
    if (segment.isExif) {
      // Fix the IFD0 segment.
      var offsetExif = apps.uploader.ExifHelper.fixIFD0_(newBuffer, offset,
          oldWidth, oldHeight, newWidth, newHeight);

      // Fix the EXIF IFD segment within the EXIF APP1 segment, if present.
      if (offsetExif) {
        apps.uploader.ExifHelper.fixExif_(newBuffer, offset, offsetExif,
            newWidth, newHeight);
      }
    }
    offset += segment.length;
  });

  return newBuffer;
};


/**
 * Takes a byte stream of JPEG data, and splice in a new header bytes generated
 * by the {@link #createHeader} method.
 * <p>
 * Note that the resulting blob is a fake string for XHR.send.  This step
 * wouldn't necesary for Mozilla if one called XHR.sendAsBinary instead, but
 * this means special- casing the XhrFileIo and ResumableXhrFileIo classes.  For
 * additional information, see
 * {@link http://javascript0.org/wiki/Portable_sendAsBinary}.
 * </p>
 * @param {!string} contentType MIME content type of the binary data.
 * @param {goog.array.ArrayLike} data Binary data, in string form.
 * @param {Array.<number>=} opt_header Optional APP1 information, generated from
 *     the original image.
 * @return {Blob} A Blob if data is valid, null if not.
 */
apps.uploader.ExifHelper.CreateBlobWithNewHeader = function(contentType, data,
    opt_header) {
  var sliceStart = 0;
  var sliceEnd = 0;
  var i;
  if (opt_header) {
    // Either splice the new header (i) over the existing APP1 segment, or (ii)
    // immediately after the APP0, or if neither is found (iii) immediately
    // after the SOI.  It's generally OK to have multiple APPn segments, but we
    // want to replace the minimal APP1 segement generated by the UA with the
    // one passed in, as the original image header will contain much richer
    // information about the image, such as source, location, copyright.
    i = 0;
    while (i < data.length) {
      var c = data.charCodeAt(i++);
      if (c != 255) {
        break;
      }
      c = data.charCodeAt(i++);
      if (c == 0xd8) {
        // SOI=Start of Image.  Required; continue.
        sliceStart = sliceEnd = i;
      } else if (c == 0xe0) {
        // APP0 segment.  Next two bytes indicate segment length.
        i += ((data.charCodeAt(i) & 0xff) << 8) +
            (data.charCodeAt(i + 1) & 0xff);
        sliceStart = sliceEnd = i;
      } else if (c == 0xe1) {
        // Existing APP1 segment.  Include marker in sliceStart.
        sliceStart = i - 2;
        sliceEnd = i + ((data.charCodeAt(i) & 0xff) << 8) +
            (data.charCodeAt(i + 1) & 0xff);
        break;
      } else {
        // Not sure about segment type/length.  Bail.
        break;
      }
    }

    if (sliceStart == 0) {
      // No SOI found, which means the data is invalid.
      return null;
    }
  }

  var app1Length = opt_header ? opt_header.length : 0;
  var buffer = new Uint8Array(data.length + app1Length);

  i = 0;
  var j;
  for (j = 0; j < sliceStart; j++, i++) {
    buffer[i] = data.charCodeAt(j) & 0xff;
  }
  for (j = 0; j < app1Length; j++, i++) {
    buffer[i] = opt_header[j] & 0xff;
  }
  for (j = sliceEnd; j < data.length; j++, i++) {
    buffer[i] = data.charCodeAt(j) & 0xff;
  }

  return goog.fs.getBlob(buffer.buffer);
};


/**
 * APP1 TIFF (0th) directory marker values.
 * @enum {number}
 * @const
 */
apps.uploader.ExifHelper.TiffTagId = {
  IMAGE_WIDTH: 0x100,
  IMAGE_HEIGHT: 0x101,
  X_RESOLUTION: 0x11a,
  Y_RESOLUTION: 0x11b,
  EXIF_IFD_POINTER: 0x8769
};


/**
 * APP1 Exif directory marker values.
 * @enum {number}
 * @const
 */
apps.uploader.ExifHelper.ExifTagId = {
  IMAGE_WIDTH: 0xa002,
  IMAGE_HEIGHT: 0xa003
};


/**
 * Markers for segments that get transferred from the old image to the new one,
 * hence 'of interest'.  The value represents the second byte of a JPEG header
 * marker value.  The first byte is always 0xff.
 * @enum {number}
 * @private
 */
apps.uploader.ExifHelper.MarkerOfInterest_ = {
  APP1: 0xe1,
  APP12: 0xec,
  COM: 0xfe
};


/**
 * Collects a list of header segments of interest, and the offset index of them,
 * out of a JPEG buffer.
 * @param {!Uint8Array} buffer The raw bytes out of the file.
 * @return {!Array.<*>} An array of objects, each representing a segment.
 * @private
 */
apps.uploader.ExifHelper.findSegmentsOfInterest_ = function(buffer) {
  var segments = [];

  // Make sure the image starts with an SOI (0xffd8).
  if (buffer.byteLength < 2 ||
      buffer[0] != 0xff ||
      buffer[1] != 0xd8) {
    // 0xd8: SOI = Start of Image.
    return [];
  }

  for (var i = 2; i < buffer.byteLength;) {
    var c = buffer[i++];
    // All markers should start with 0xFF.
    if (c != 0xff) {
      return [];
    }

    // Get the second by of the marker.
    c = buffer[i++];

    // The next two bytes represent the segment length.
    var segmentLengthNotIncludingMarker = (buffer[i] << 8) + buffer[i + 1];

    switch (c) {
      case apps.uploader.ExifHelper.MarkerOfInterest_.APP1:
        // Check for the signature for sanity check.
        var endian = buffer[i + 8];
        var exifSegment = buffer[i + 2] == 0x45 && // 'E'
            buffer[i + 3] == 0x78 && // 'x'
            buffer[i + 4] == 0x69 && // 'i'
            buffer[i + 5] == 0x66 && // 'f'
            buffer[i + 6] == 0 &&
            buffer[i + 7] == 0 &&
            endian == buffer[i + 9] && // Should be II or MM
            (endian == 0x49 || endian == 0x4d) &&
            (apps.uploader.ExifHelper.readShort_(buffer, i + 10,
                endian == 0x49) == 42);
        segments.push({marker: c,
          offset: i - 2,
          length: segmentLengthNotIncludingMarker + 2,
          isExif: exifSegment});
        break;

      case apps.uploader.ExifHelper.MarkerOfInterest_.APP12:
        segments.push({marker: c,
          offset: i - 2,
          length: segmentLengthNotIncludingMarker + 2});
        break;

      case 0xda:
        // 0xda: SOS = Start of Scan. Stop looking for more header segments.
        return segments;

      case 0xd8:
        // 0xd8: SOI = Start of Image.
        // An error if not at the beginning.
        return [];

      case 0xd9:
        // 0xd9: EOI = End of Image.
        // Should have seen an SOS before the EOI.
        return [];
    }

    i += segmentLengthNotIncludingMarker;
  }

  return segments;
};


/**
 * Returns a 2-byte value at a given index, honoring the endian-ness.
 * @param {!Uint8Array} buffer Data buffer.
 * @param {!number} index Index into the data buffer.  No boundary checks are
 *     performed.
 * @param {!boolean} littleEndian True if data buffers is little-endian, false
 *     if big-endian.
 * @return {number} A short value from the buffer.
 * @private
 */
apps.uploader.ExifHelper.readShort_ = function(buffer, index, littleEndian) {
  var bias = littleEndian ? 1 : 0;
  return (buffer[index + bias] << 8) + buffer[index + 1 - bias];
};


/**
 * Returns a 4-byte value at a given index, honoring the endian-ness.
 * @param {!Uint8Array} buffer Data buffer.
 * @param {!number} index Index into the data buffer.  No boundary checks are
 *     performed.
 * @param {!boolean} littleEndian True if data buffers is little-endian, false
 *     if big-endian.
 * @return {number} A short value from the buffer.
 * @private
 */
apps.uploader.ExifHelper.readLong_ = function(buffer, index, littleEndian) {
  var bias = littleEndian ? 1 : 0;
  return (buffer[index + 3 * bias] << 24) + (buffer[index + 1 + bias] << 16) +
      (buffer[index + 2 - bias] << 8) + buffer[index + 3 - 3 * bias];
};


/**
 * Writes a 4-byte value at a given index, honoring the endian-ness.
 * @param {!Uint8Array} buffer Data buffer.
 * @param {!number} index Index into the data buffer.  No boundary checks are
 *     performed.
 * @param {!number} value The value to write.
 * @param {!boolean} littleEndian True if data buffers is little-endian, false
 *     if big-endian.
 * @private
 */
apps.uploader.ExifHelper.writeLong_ = function(buffer, index, value,
    littleEndian) {
  var bias = littleEndian ? 1 : 0;
  buffer[index + 3 - 3 * bias] = value & 0xff;
  buffer[index + 2 - bias] = (value >> 8) & 0xff;
  buffer[index + 1 + bias] = (value >> 16) & 0xff;
  buffer[index + 3 * bias] = (value >> 24) & 0xff;
};


/**
 * Writes two 4-byte values at a given index, representing a rational number,
 * i.e. a fraction that approximates a floating point number, while honoring
 * the endian-ness.
 * @param {!Uint8Array} buffer Data buffer.
 * @param {!number} index Index into the data buffer.  No boundary checks are
 *     performed.
 * @param {!number} value Numeric value to write.
 * @param {!boolean} littleEndian True if data buffers is little-endian, false
 *     if big-endian.
 * @private
 */
apps.uploader.ExifHelper.writeRational_ = function(buffer, index, value,
    littleEndian) {
  var pair = apps.uploader.ExifHelper.rationalFromNumber_(value);
  apps.uploader.ExifHelper.writeLong_(buffer, index, pair[0], littleEndian);
  apps.uploader.ExifHelper.writeLong_(buffer, index + 4, pair[1], littleEndian);
};


/**
 * Convert a number to a rational value, a ratio of two integers.  From
 * {@link http://www.ics.uci.edu/~eppstein/numth/frap.c}.
 * @param {!number} x Input value.
 * @return {!Array.<number>} An array of two integral numbers, representing the
 *     numerator and denominator, respectively.
 * @private
 */
apps.uploader.ExifHelper.rationalFromNumber_ = function(x) {
  // Short-circuit the integer case.
  if (goog.math.isInt(x)) {
    return [x, 1];
  }

  var isNegative = x < 0;
  x = Math.abs(x);
  var startx = x;
  var maxden = 10000000; // Maximum denominator, chosen arbitrarily.

  var m00 = 1;
  var m11 = 1;
  var m01 = 0;
  var m10 = 0;
  var ai;

  while (m10 * (ai = Math.floor(x)) + m11 <= maxden) {
    var t = m00 * ai + m01;
    m01 = m00;
    m00 = t;
    t = m10 * ai + m11;
    m11 = m10;
    m10 = t;
    var denom = x - ai;
    if (denom < 1e-6) {
      break;
    }
    x = 1 / denom;
    if (denom > 0x7fffffff) {
      break;
    }
  }

  return [isNegative ? -m00 : m00, m10];
};


/**
 * Offset for offsets within the APP1 segment.  All offsets are relative to the
 * endian-ness marker (II or MM) which is itself 10-bytes from the beginning of
 * the APP1 segment.
 * @type {!number}
 * @const
 * @private
 */
apps.uploader.ExifHelper.OFFSET_BASE_ = 10;


/**
 * Fix various entries inside the TIFF (aka 0th) directory within the APP1
 * segment.  Helper method for {@code createHeader}.
 * @param {!Uint8Array} buffer The raw bytes out of the file, starting at the
 *     beginning of the APP1 segment, including the APP1 marker.
 * @param {!number} offset0 First offset of the APP1 segment within the buffer.
 * @param {!number} oldWidth Old width of the image, in pixels.
 * @param {!number} oldHeight Old Height of the image, in pixels.
 * @param {!number} newWidth New width of the image, in pixels.
 * @param {!number} newHeight New height of the image, in pixels.
 * @return {number|undefined} The offset of EXIF IFD, if found.
 * @private
 */
apps.uploader.ExifHelper.fixIFD0_ = function(buffer, offset0, oldWidth,
    oldHeight, newWidth, newHeight) {
  // 'I' for Intel, 'M' for Motorola
  var littleEndian = buffer[offset0 + 10] == 0x49;
  var offsetIFD0 = apps.uploader.ExifHelper.readLong_(buffer, offset0 + 14,
      littleEndian) + apps.uploader.ExifHelper.OFFSET_BASE_;
  var countIFD0 = apps.uploader.ExifHelper.readShort_(buffer, offsetIFD0,
      littleEndian);
  var offset = 2 + offsetIFD0; // +2 to pass the count.
  var offsetStop = offset + countIFD0 * 12;
  var offsetExif;
  for (; offset < offsetStop; offset += 12) {
    var marker = apps.uploader.ExifHelper.readShort_(buffer, offset,
        littleEndian);
    switch (marker) {
      case apps.uploader.ExifHelper.TiffTagId.IMAGE_WIDTH:
        apps.uploader.ExifHelper.writeLong_(buffer, offset + 8, newWidth,
            littleEndian);
        break;
      case apps.uploader.ExifHelper.TiffTagId.IMAGE_HEIGHT:
        apps.uploader.ExifHelper.writeLong_(buffer, offset + 8, newHeight,
            littleEndian);
        break;
      case apps.uploader.ExifHelper.TiffTagId.X_RESOLUTION:
      case apps.uploader.ExifHelper.TiffTagId.Y_RESOLUTION:
        var offsetData = apps.uploader.ExifHelper.readLong_(buffer, offset + 8,
            littleEndian) + apps.uploader.ExifHelper.OFFSET_BASE_;
        var numer = apps.uploader.ExifHelper.readLong_(buffer, offsetData,
            littleEndian);
        var denom = apps.uploader.ExifHelper.readLong_(buffer, offsetData + 4,
            littleEndian);
        var oldResolution = numer / denom;
        var newResolution = oldResolution *
            ((marker == apps.uploader.ExifHelper.TiffTagId.X_RESOLUTION) ?
                (newWidth / oldWidth) : (newHeight / oldHeight));
        apps.uploader.ExifHelper.writeRational_(buffer, offsetData,
            newResolution, littleEndian);
        break;
      case apps.uploader.ExifHelper.TiffTagId.EXIF_IFD_POINTER:
        offsetExif = apps.uploader.ExifHelper.readLong_(buffer, offset + 8,
            littleEndian) + apps.uploader.ExifHelper.OFFSET_BASE_;
        break;
    }
  }

  return offsetExif;
};


/**
 * Fix various entries inside the EXIF IFD within the APP1 segment.
 * Helper method for {@code createHeader}.
 * @param {!Uint8Array} buffer The raw bytes out of the file.
 * @param {!number} offset0 First offset of the APP1 segment within the buffer.
 * @param {!number} offsetEXIF Offset in to EXIF directory within buffer.
 * @param {!number} newWidth New width of the image, in pixels.
 * @param {!number} newHeight New height of the image, in pixels.
 * @private
 */
apps.uploader.ExifHelper.fixExif_ = function(buffer, offset0, offsetEXIF,
    newWidth, newHeight) {
  // 'I' for Intel, 'M' for Motorola
  var littleEndian = buffer[offset0 + 10] == 0x49;
  var countEXIF = apps.uploader.ExifHelper.readShort_(buffer, offsetEXIF,
      littleEndian);
  var offset = 2 + offsetEXIF; // +2 to pass the count.
  var offsetStop = offset + countEXIF * 12;
  for (; offset < offsetStop; offset += 12) {
    var marker = apps.uploader.ExifHelper.readShort_(buffer, offset,
        littleEndian);
    switch (marker) {
      case apps.uploader.ExifHelper.ExifTagId.IMAGE_WIDTH:
        apps.uploader.ExifHelper.writeLong_(buffer, offset + 8, newWidth,
            littleEndian);
        break;

      case apps.uploader.ExifHelper.ExifTagId.IMAGE_HEIGHT:
        apps.uploader.ExifHelper.writeLong_(buffer, offset + 8, newHeight,
            littleEndian);
        break;
    }
  }
};
